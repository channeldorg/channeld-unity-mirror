using Channeld;
using Google.Protobuf;
using Google.Protobuf.Collections;
using Mirror;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class ChanneldTransport : Transport
{
    public Transport serverTransport;
    public Transport clientTransport;
    public ChannelType ServerChannelType = ChannelType.Global;
    public uint ChannelFanOutIntervalMsForServer = 10;
    public uint ChannelFanOutIntervalMsForClient = 50;
    public string ServerChannelMetadata = "MirrorServer";
    public uint ChanneldConnId { get; private set; }
    public uint TargetChannelId { get; private set; } = 0;

    private NetworkReader msgTypeReader = new NetworkReader(new byte[0]);

    static ArraySegment<byte> Marshal(uint channelId, BroadcastType broadcast, uint stubId, uint msgType, IMessage msg)
    {
        return Marshal(channelId, broadcast, stubId, msgType, new ArraySegment<byte>(msg.ToByteArray()));
    }

    static ArraySegment<byte> Marshal(uint channelId, BroadcastType broadcast, uint stubId, uint msgType, ArraySegment<byte> segment)
    {
        var packet = new Packet
        {
            ChannelId = channelId,
            Broadcast = broadcast,
            StubId = stubId,
            MsgType = msgType,
            MsgBody = ByteString.CopyFrom(segment.Array, segment.Offset, segment.Count)
        };
        var bytes = packet.ToByteArray();
        var buf = new MemoryStream(bytes.Length + 4);
        var tag = new byte[] { 67, 72, 78, 76 };
        tag[3] = (byte)(bytes.Length & 0xff);
        if (bytes.Length > 0xff)    tag[2] = (byte)((bytes.Length >> 8) & 0xff);
        if (bytes.Length > 0xffff)  tag[1] = (byte)((bytes.Length >> 16) & 0xff);
        buf.Write(tag, 0, 4);
        buf.Write(bytes, 0, bytes.Length);
        return new ArraySegment<byte>(buf.ToArray());
    }

    static Packet Unmarshal(ArraySegment<byte> segment)
    {
        var bytes = segment.Array;
        if (bytes[0] != 67)
            throw new IOException("invalid tag");

        int size = bytes[3];
        if (bytes[1] != 72)
        {
            size = size | bytes[1] << 16 | bytes[2] << 8;
        }
        else if (bytes[2] != 78)
        {
            size = size | bytes[2] << 8;
        }

        if (segment.Count < size + 4)
            throw new IOException("segment doesn't have a complete packet");

        return Packet.Parser.ParseFrom(bytes, 4, size);
    }

    private uint ToChanneldMsgType(ArraySegment<byte> segment)
    {
        ushort msgType;
        msgTypeReader.SetBuffer(segment);
        if (MessagePacking.Unpack(msgTypeReader, out msgType))
        {
            msgType += (ushort)MessageType.UserSpaceStart;
        }
        else
        {
            msgType = (ushort)MessageType.UserSpaceStart;
        }
        return msgType;
    }

    struct MessageHandlerEntry
    {
        public MessageParser Parser { get; private set; }
        public Action<uint, IMessage> Handler { get; private set; }
        public MessageHandlerEntry(MessageParser parser, Action<uint, IMessage> handler)
        {
            Parser = parser;
            Handler = handler;
        }
    }

    #region Server Logic

    void HandleServerAuth(uint channelId, IMessage m)
    {
        var msg = (AuthResultMessage)m;
        if (msg.Result == AuthResultMessage.Types.AuthResult.Successful)
        {
            ChanneldConnId = msg.ConnId;
            
            ServerSend(0, BroadcastType.No, MessageType.CreateChannel, new CreateChannelMessage
            {
                ChannelType = ServerChannelType,
                Metadata = ServerChannelMetadata,
                SubOptions = new ChannelSubscriptionOptions
                {
                    CanUpdateData = true,
                    FanOutIntervalMs = ChannelFanOutIntervalMsForServer
                }
            });

            // Calls NetworkServer.OnTransportConnected()
            //this.OnServerConnected.Invoke((int)connId);
        }
        else
        {
            this.OnServerError((int)msg.ConnId, new Exception("Authentication failed:" + msg.Result.ToString()));
        }
    }

    void HandleServerSubToChannel(uint channelId, IMessage m)
    {
        var msg = (SubscribedToChannelMessage)m;
        if (msg.ConnId == ChanneldConnId)
        {
            // Owned the GLOBAL channel
            TargetChannelId = channelId;
        }
        else
        {
            // The client subscribed to the GLOBAL channel
            this.OnServerConnected.Invoke((int)msg.ConnId);
        }
    }

    private Dictionary<uint, MessageHandlerEntry> serverMessageHandlers = new Dictionary<uint, MessageHandlerEntry>();

    public override void ServerStart()
    {
        serverMessageHandlers.Add((uint)MessageType.Auth, new MessageHandlerEntry(AuthResultMessage.Parser, HandleServerAuth));
        serverMessageHandlers.Add((uint)MessageType.SubToChannel, new MessageHandlerEntry(SubscribedToChannelMessage.Parser, HandleServerSubToChannel));

        serverTransport.OnClientConnected = () =>
        {
            // TODO: Server authentication to channeld
            ServerSend(0, BroadcastType.No, MessageType.Auth, new AuthMessage
            {
                LoginToken = "test",
                PlayerIdentifierToken = "test",
            });
        };
        serverTransport.OnClientDataReceived = (ArraySegment<byte> data, int channelId) =>
        {
            var p = Unmarshal(data);
            if (p.MsgType >= (uint)MessageType.UserSpaceStart)
            {
                var usm = UserSpaceMessage.Parser.ParseFrom(p.MsgBody.ToByteArray());
                this.OnServerDataReceived((int)usm.SourceConnId, new ArraySegment<byte>(usm.MsgBody.ToByteArray()), channelId);
            }
            else
            {
                MessageHandlerEntry entry;
                if (serverMessageHandlers.TryGetValue(p.MsgType, out entry))
                {
                    var msg = entry.Parser.ParseFrom(p.MsgBody.ToByteArray());
                    entry.Handler(p.ChannelId, msg);
                }
                else
                {
                    this.OnServerError(0, new Exception("Cannot find handler by message type:" + p.MsgType));
                }
            }
        };
        serverTransport.OnClientDisconnected = this.OnClientDisconnected;
        serverTransport.OnClientError = this.OnClientError;
        serverTransport.ClientConnect(NetworkManager.singleton.networkAddress);
    }

    public override void ServerSend(int connectionId, ArraySegment<byte> segment, int channelId)
    {
        // Send the packet to channeld and forward to the client connection.
        serverTransport.ClientSend(Marshal((uint)connectionId, BroadcastType.SingleConnection, 0, ToChanneldMsgType(segment), segment), channelId);
    }

    public void ServerSend(uint channelId, BroadcastType broadcast, MessageType msgType, IMessage msg)
    {
        serverTransport.ClientSend(Marshal(channelId, broadcast, 0, (uint)msgType, msg), Channels.Reliable);
    }

    public override void ServerEarlyUpdate()
    {
        if (enabled) serverTransport.ClientEarlyUpdate();
    }

    public override void ServerLateUpdate()
    {
        serverTransport.ClientLateUpdate();
    }

    public override Uri ServerUri() => serverTransport.ServerUri();

    public override bool ServerActive() => serverTransport.ClientConnected();

    public override void ServerDisconnect(int connectionId)
    {
        ServerSend(0, BroadcastType.No, MessageType.Disconnect, new DisconnectMessage()
        {
            ConnId = (uint)connectionId
        });
    }

    // Getting the address of the client connection in channeld is not supported.
    public override string ServerGetClientAddress(int connectionId) => null;

    public override void ServerStop() => serverTransport.ClientDisconnect();

    #endregion


    #region Client Logic

    private Dictionary<uint, MessageHandlerEntry> clientMessageHandlers = new Dictionary<uint, MessageHandlerEntry>();

    public override void ClientConnect(string address)
    {
        InitClientConnection();
        clientTransport.ClientConnect(address);
    }
    public override void ClientConnect(Uri uri)
    {
        InitClientConnection();
        clientTransport.ClientConnect(uri);
    }

    private void InitClientConnection()
    {
        clientMessageHandlers.Add((uint)MessageType.Auth, new MessageHandlerEntry(AuthResultMessage.Parser, HandleClientAuth));
        clientMessageHandlers.Add((uint)MessageType.ListChannel, new MessageHandlerEntry(ListChannelResultMessage.Parser, HandleClientListChannel));
        clientMessageHandlers.Add((uint)MessageType.SubToChannel, new MessageHandlerEntry(SubscribedToChannelMessage.Parser, HandleClientSubToChannel));

        clientTransport.OnClientConnected = this.OnClientConnected;
        clientTransport.OnClientDataReceived = (ArraySegment<byte> data, int channelId) =>
        {
            var p = Unmarshal(data);
            if (p.MsgType >= (uint)MessageType.UserSpaceStart)
            {
                var usm = UserSpaceMessage.Parser.ParseFrom(p.MsgBody.ToByteArray());
                this.OnClientDataReceived(new ArraySegment<byte>(p.MsgBody.ToByteArray()), channelId);
            }
            else
            {
                MessageHandlerEntry entry;
                if (clientMessageHandlers.TryGetValue(p.MsgType, out entry))
                {
                    var msg = entry.Parser.ParseFrom(p.MsgBody.ToByteArray());
                    entry.Handler(p.ChannelId, msg);
                }
                else
                {
                    this.OnClientError(new Exception("Cannot find handler by message type:" + p.MsgType));
                }
            }
        };

        clientTransport.OnClientDisconnected = this.OnClientDisconnected;
    }

    public override void ClientSend(ArraySegment<byte> segment, int channelId)
    {
        clientTransport.ClientSend(Marshal(TargetChannelId, BroadcastType.No, 0, ToChanneldMsgType(segment), segment), channelId);
    }

    public void ClientSend(uint channelId, BroadcastType broadcast, MessageType msgType, IMessage msg)
    {
        clientTransport.ClientSend(Marshal(channelId, broadcast, 0, (uint)msgType, msg), Channels.Reliable);
    }


    void HandleClientAuth(uint channelId, IMessage m)
    {
        var msg = (AuthResultMessage)m;
        if (msg.Result == AuthResultMessage.Types.AuthResult.Successful)
        {
            ChanneldConnId = msg.ConnId;
            ClientSend(0, BroadcastType.No, MessageType.ListChannel, new ListChannelMessage()
            {
                TypeFilter = ServerChannelType
            });
        }
        else
        {
            this.OnClientError(new Exception("Authentication failed:" + msg.Result.ToString()));

        }
    }

    void HandleClientListChannel(uint channelId, IMessage m)
    {
        var msg = (ListChannelResultMessage)m;
        if (msg.Channels.Count == 0)
        {
            this.OnClientError(new Exception("No channel to subscribe"));
            return;
        }

        // TODO: Client selects the channel to join. Uses something like the @MatchNetworkManager
        var channelToSub = msg.Channels[UnityEngine.Random.Range(0, msg.Channels.Count)];
        ClientSend(channelToSub.ChannelId, BroadcastType.No, MessageType.SubToChannel, new SubscribedToChannelMessage()
        {
            ConnId = ChanneldConnId,
            SubOptions = new ChannelSubscriptionOptions
            {
                CanUpdateData = true,
                FanOutIntervalMs = ChannelFanOutIntervalMsForClient
            }
        });
    }

    void HandleClientSubToChannel(uint channelId, IMessage m)
    {
        var msg = (SubscribedToChannelMessage)m;
        if (msg.ConnId == ChanneldConnId)
        {
            // Owned the GLOBAL channel
            TargetChannelId = channelId;
            if (NetworkManager.singleton.authenticator != null)
            {
                // Fake an AuthRespondMessage and pass it to NetworkClient.OnTransportData()
                using (PooledNetworkWriter writer = NetworkWriterPool.GetWriter())
                {
                    var arm = new Mirror.Authenticators.BasicAuthenticator.AuthResponseMessage()
                    {
                        code = 100,
                        message = "Success"
                    };

                    MessagePacking.Pack(arm, writer);

                    this.OnClientDataReceived(writer.ToArraySegment(), Channels.Reliable);
                }
            }
        }

    }

    public override void ClientEarlyUpdate()
    {
        if (enabled) clientTransport.ClientEarlyUpdate();
    }

    public override void ClientLateUpdate()
    {
        clientTransport.ClientLateUpdate();
    }

    public override bool ClientConnected() => clientTransport.ClientConnected();

    public override void ClientDisconnect() => clientTransport.ClientDisconnect();

   #endregion

    public override bool Available() => serverTransport.Available() && clientTransport.Available();

    public override int GetMaxPacketSize(int channelId = 0) => serverTransport.GetMaxPacketSize(channelId);

    public override void Shutdown()
    {
        clientTransport.Shutdown();
        serverTransport.Shutdown();
    }
}

